[{"uri":"https://aristanetworks.github.io/cloudvision-apis/clients/existing/","title":"Existing Clients","tags":[],"description":"","content":"Arista provides and maintains the following clients:\n   Language Repository     Go https://github.com/aristanetworks/cloudvision-go   Python https://github.com/aristanetworks/cloudvision-python    "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/modeling/","title":"Modeling","tags":[],"description":"","content":"Resources are modeled in Protobuf and accessed over gRPC with a standardized set of RPCs (discussed in later sections). These models are divided into two types:\n config: models which allow user-modification, exposing modifiable/tunable options. state: models which expose read-only operational and/or derived state based on config data.  Config Models Config models describe the user\u0026rsquo;s interaction with the system. Fields in these models are populated by the user (or by defaults).\nConfig models are read-writeable, meaning their APIs expose both read and write methods. The Protobuf message extension fmp.model = \u0026quot;rw\u0026quot; denotes that a given model is used as config and the generated RPCs will expose both read and write method sets.\nState Models State models describe the operational state of the system. Fields in these models are populated by the system and are not modifiable (except through the relevant config model).\nState models only have read methods defined and are denoted with the Protobuf message extension fmp.model = \u0026quot;ro\u0026quot;.\nWhile not required, state models are allowed to \u0026ldquo;echo\u0026rdquo; the associated config model for convenience of the user. You should check the relevant model(s) before expecting this behaviour, however.\nHigh Level Config-State Flow Below is a diagram explaining the data flow from writing a Config to the system creating/updating State. Typically, this process is asynchronous and the client will receive a response to the Set request before the state is readable. Verification and durably storing the config are the only gating requirements to responding to the Config write-request.\nWhile the config request is an input to deriving the state, there are other (possible) inputs into state:\n non-configurable on-device settings or data (ex: device boot time) CloudVision configuration (ex: default user permissions) related config/state models (if noted in documentation) etc  Subscribing to State (ideally, with a filter) allows the client to wait for any asynchronous processing.\nAll responses from RPCs include a timestamp. This timestamp should be viewed as the time at which the system durably stored an action (whether config or state). Thus, all state requests will return a timestamp \u0026gt;= than that of the config that initiated the action.\nNullable Types To make partial updates (both by users into the system as well as updates from the system) possible all primitive fields, maps, and repeated fields are wrapped in nullable messages. This nullability allows both the user and the system to differentiate between unset and zero-valued fields.\nFor example:\nmessage Nullability { // This value will contain \u0026#34;\u0026#34; when not set by the user/system.  // It is not possible to know whether \u0026#34;\u0026#34; is the intended value, or simply omitted.  string unwrapped_string = 1; // This value will contain null when not set by the user/system.  // When the wrapper message is non-null, an empty string (\u0026#34;\u0026#34;) has  // the context of being intentionally set.  google.protobuf.StringValue wrapped_string = 2;}A list of the available wrapper types can be seen here, though models may define their own for maps or repeated (array) fields.\nKeys All models (whether config or state) contain a key message.\nThis key contains the minimal set of data needed to uniquely identify a given model entity. Model keys may be as simple as a single string (say, a name) or as complex as containing references to a datacenter, device, interface, or any combination of them. The complexity of the key depends entirely on the model at hand.\nMessages used for keys are denoted in protobuf with the extension: fmp.model_key = true.\n"},{"uri":"https://aristanetworks.github.io/cloudvision-apis/clients/creating/","title":"Creating a Client","tags":[],"description":"","content":"A major advantage to Protobuf (and gRPC) is the ability to generate language bindings reliably and dependably.\nThe main gRPC site has tutorials for generating clients in many languages:\n Java Node Ruby C#/.Net \u0026hellip; and more  There is also an expansive ecosystem, so plenty of languages are supported.\nTooling In general, there are two main components to generating a language binding:\n protoc: The protobuf compiler which call the language-specific generator  typically installed via a package manager (apt, yum, brew, etc)   protoc-gen-{language}: The language-specific generator  typically installed with the language\u0026rsquo;s dependency manager, build tool, etc    Generating Regardless of language, client generation generally follows a pattern of:\n$ protoc {includes} {lang-opts} {output-opts} {inputs} We are primarily concerned with the {includes} and {inputs} bits. The rest of the options are up to you.\nThe .proto files used as inputs can be found in: cloudvision-apis repo. You should first clone (or download) that repository. Once you have it, generating a client is as simple as:\n$ export CVAPIS=/some/path/to/cloudvision-apis $ git clone https://github.com/aristanetworks/cloudvision-apis $CVAPIS $ protoc -I $CVAPIS \\  {language-specific options go here} \\  $CVAPIS/arista/example.v1/example.proto $CVAPIS/arista/example.v1/services.gen.proto In the above examples we generate the protobuf bindings (example.proto) as well as the gRPC services (services.gen.go) in the same command. You are free to do them separately, however, different language generators handle this differently.\n"},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/errors/","title":"Error Handling","tags":[],"description":"","content":"Errors returned by the API follow the gRPC status code guidelines. This provides many niceties:\n Language-native idioms (exceptions, return codes, etc.) Easily mappable to HTTP error codes (used for HTTP access to RPCs) Uses metadata rather than a global schema for more detailed errors  Example: Go Unary RPCs resp, err := example.GetOne(ExampleConfigRequest{Key: key}) if err != nil { log.Printf(\u0026#34;failed to get %+v: %s\\n\u0026#34;, key, err) return err } Streaming RPCs stream, err := example.GetAll(ExampleConfigStreamRequest{...}) if err != nil { log.Fatalf(\u0026#34;failed to initialize GetAll stream: %s\u0026#34;, err) } for { value, err := stream.Recv() if err == io.EOF { // all done  break } else if err != nil { // stream was broken due to error  log.Fatalf(\u0026#34;stream was interrupted: %s\u0026#34;, err) } log.Printf(\u0026#34;%+v\\n\u0026#34;, value) } Example: Python Unary RPCs try: response = example_stub.Set(ExampleConfigSetRequest(...)) except grpc.RpcError as e: print(\u0026#39;Set failed: {0}: {1}\u0026#39;.format(e.code(), e.details())) raise e Streaming RPCs try: for resource in example_stub.GetAll(ExampleConfigStreamRequest(...)): # process resource except grpc.RpcError as e: print(\u0026#39;GetAll failed: {0}: {1}\u0026#39;.format(e.code(), e.details())) raise e "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/","title":"Uniform RPCs","tags":[],"description":"","content":"As stated previously, APIs are accesible over gRPC with a standardized set of RPCs.\nThese methods will behave consistently across models.\nRead Methods All readable models have the following RPC signatures:\nservice ExampleConfigService { rpc GetOne (ExampleConfigRequest) returns (ExampleConfigResponse); rpc GetAll (ExampleConfigStreamRequest) returns (stream ExampleConfigStreamResponse); rpc Subscribe (ExampleConfigStreamRequest) returns (stream ExampleConfigStreamResponse);}The ExampleConfigRequest, ExampleConfigResponse, ExampleConfigStreamRequest, and ExampleConfigStreamResponse are generated wrappers for a given model (ExampleConfig, in this example). By generating these wrappers we provide further consistency in request parameters.\nWrite Methods All wriable models have the following RPC signatures:\nservice ExampleConfigService { rpc Set (ExampleConfigSetRequest) returns (ExampleConfigSetResponse); rpc Delete (ExampleConfigDeleteRequest) returns (ExampleConfigDeleteResponse);}The ExampleConfigSetRequest, ExampleConfigSetResponse, ExampleConfigDeleteRequest, and ExampleConfigDeleteResponse are generated wrappers for a given model (ExampleConfig, in this example). By generating these wrappers we provide further consistency in request parameters.\n"},{"uri":"https://aristanetworks.github.io/cloudvision-apis/connecting/","title":"Connecting","tags":[],"description":"","content":"The port used to connect to CVP depends on your environment:\n On-prem CVP deployments: 8443 CloudVision as a Service: 443  Authentication Our APIs currently support token based authentication.\nIn future releases we intend to support mutual TLS authentication which does not require tokens or login credentials to be stored along with the application.\nFor more details on gRPC authentication, see: authentication.\nToken Based Authentication This style of authentication uses the token received from the HTTP login API.\nThe following examples use python but Go, Java, or any other language capable of HTTP requests will work almost identically. To make the HTTP request, we will use the requests library which is available through pip:\npython -m pip install requests Example: token from login import requests import json import grpc CV_HOST = \u0026#34;your_cvp_hostname_or_ip\u0026#34; CV_API_PORT = \u0026#34;8443\u0026#34; USERNAME = \u0026#34;your_cvp_username\u0026#34; PASSWORD = \u0026#34;your_cvp_password\u0026#34; r = requests.post(\u0026#39;https://\u0026#39; + CV_HOST + \u0026#39;/cvpservice/login/authenticate.do\u0026#39;, auth=(USERNAME, PASSWORD)) channel_credentials = grpc.ssl_channel_credentials() call_credentials = grpc.access_token_call_credentials(r.json()[\u0026#39;sessionId\u0026#39;]) combined_credentials = grpc.composite_channel_credentials(channel_credentials, call_credentials) channel = grpc.secure_channel(CV_HOST + \u0026#39;:\u0026#39; + CV_API_PORT, combined_credentials) Example: token with loading custom SSL/TLS root certificates If CVP is using a certificate signed by a certificate authority that is not installed as a root certificate, specify it like so:\nimport requests import json import grpc CV_HOST = \u0026#34;your_cvp_hostname_or_ip\u0026#34; CV_API_PORT = \u0026#34;8443\u0026#34; USERNAME = \u0026#34;your_cvp_username\u0026#34; PASSWORD = \u0026#34;your_cvp_password\u0026#34; # The certificate authority that signed the CVP certificate. # If the CVP certificate is self-signed, this is just the certificate itself. # The default location of CVP\u0026#39;s self-signed certificate on a node is /etc/nginx/cvp.crt CA_PUB_CERT_PATH = \u0026#34;/path/to/ca.pem\u0026#34; r = requests.post(\u0026#39;https://\u0026#39; + CV_HOST + \u0026#39;/cvpservice/login/authenticate.do\u0026#39;, auth=(USERNAME, PASSWORD), verify=CA_PUB_CERT_PATH) call_credentials = grpc.access_token_call_credentials(r.json()[\u0026#39;sessionId\u0026#39;]) with open(CA_PUB_CERT_PATH, \u0026#39;rb\u0026#39;) as cert_file: channel_credentials = grpc.ssl_channel_credentials(cert_file.read()) combined_credentials = grpc.composite_channel_credentials(channel_credentials, call_credentials) channel = grpc.secure_channel(CV_HOST + \u0026#39;:\u0026#39; + CV_API_PORT, combined_credentials) Or download the certificate used by the server. Note that this is insecure.\nimport requests import json import ssl import tempfile import grpc CV_HOST = \u0026#34;your_cvp_hostname_or_ip\u0026#34; CV_API_PORT = \u0026#34;8443\u0026#34; USERNAME = \u0026#34;your_cvp_username\u0026#34; PASSWORD = \u0026#34;your_cvp_password\u0026#34; cert = bytes(ssl.get_server_certificate((CV_HOST, 443))) r = requests.post(\u0026#39;https://\u0026#39; + CV_HOST + \u0026#39;/cvpservice/login/authenticate.do\u0026#39;, auth=(USERNAME, PASSWORD), verify=False) call_credentials = grpc.access_token_call_credentials(r.json()[\u0026#39;sessionId\u0026#39;]) channel_credentials = grpc.ssl_channel_credentials(cert) combined_credentials = grpc.composite_channel_credentials(channel_credentials, call_credentials) channel = grpc.secure_channel(CV_HOST + \u0026#39;:\u0026#39; + CV_API_PORT, combined_credentials) Example: token from file import grpc CV_HOST = \u0026#34;your_cvp_hostname_or_ip\u0026#34; CV_API_PORT = \u0026#34;8443\u0026#34; # The certificate authority that signed the CVP certificate. # If the CVP certificate is self-signed, this is just the certificate itself. # The default location of CVP\u0026#39;s self-signed certificate on a node is /etc/nginx/cvp.crt CA_PUB_CERT_PATH = \u0026#34;/path/to/ca.pem\u0026#34; with open(\u0026#39;cloudvision_access_token.txt\u0026#39;, \u0026#39;r\u0026#39;) as f: call_credentials = grpc.access_token_call_credentials(f.read().strip()) with open(CA_PUB_CERT_PATH, \u0026#39;rb\u0026#39;) as cert_file: channel_credentials = grpc.ssl_channel_credentials(cert_file.read()) combined_credentials = grpc.composite_channel_credentials(channel_credentials, call_credentials) channel = grpc.secure_channel(CV_HOST + \u0026#39;:\u0026#39; + CV_API_PORT, combined_credentials) Example: token from environment variable import grpc CV_HOST = \u0026#34;your_cvp_hostname_or_ip\u0026#34; CV_API_PORT = \u0026#34;8443\u0026#34; # The certificate authority that signed the CVP certificate. # If the CVP certificate is self-signed, this is just the certificate itself. # The default location of CVP\u0026#39;s self-signed certificate on a node is /etc/nginx/cvp.crt CA_PUB_CERT_PATH = \u0026#34;/path/to/ca.pem\u0026#34; call_credentials = grpc.access_token_call_credentials(os.environ[\u0026#39;CLOUDVISION_ACCESS_TOKEN\u0026#39;]) with open(CA_PUB_CERT_PATH, \u0026#39;rb\u0026#39;) as cert_file: channel_credentials = grpc.ssl_channel_credentials(cert_file.read()) combined_credentials = grpc.composite_channel_credentials(channel_credentials, call_credentials) channel = grpc.secure_channel(CV_HOST + \u0026#39;:\u0026#39; + CV_API_PORT, combined_credentails) "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/filtering/","title":"Filtering","tags":[],"description":"","content":"Filtering is provided through a default and an (optional) additional model-specific mechanism. By default, all models support \u0026ldquo;partial equality filtering\u0026rdquo;. Models that provide a custom filtering method will document this filter-message in its model documentation.\nPartial-Equality Filters Unless intentionally disabled (and sufficiently documented), services provide a default filtering mechanism. The input type is the same as the model you are filtering, and if you wish to filter on a given field you set that field to non-nil.\nGiven:\n response: the model that may or may not be sent to the client filter: a single filter model (request allows giving multiple)  For every response in the stream, we iterate the filter list. If the filter has a field set to non-null we compare it to the response\u0026rsquo;s field value. If the values are equal we continue to the next field in the filter. If the field values do not match we \u0026ldquo;fail\u0026rdquo; the filter and move on to the next filter in the list.\nIf a response fails all filters, it is not sent to the client.\nIf a response succeeds any filter, it is sent to the client.\nService-Specific Filtering Models are allowed to also contain an \u0026ldquo;implementation specific\u0026rdquo; filter which can be more targeted, featureful, or otherwise helpful.\nThis filter type will be defined in the protobuf definition. This type should be well documented in the protobuf as well as generated documentation.\nmessage CustomFilteredStreamRequest { ... // -- documentation from the filter message type -- CustomFilter filter = 2; ... "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/clients/","title":"Clients","tags":[],"description":"","content":"Clients are generated from the base .proto files shipped in this repository using the protobuf compiler.\nWhile Arista maintains clients for some languages, creating a client for your language of choice is also possible.\n Existing Clients   Creating a Client   "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/getone/","title":"GetOne","tags":[],"description":"","content":"GetOne returns a single instance of a resource.\nThe Key field is required to be fully-specified because GetOne needs to identify exactly-one resource to fetch.\n RPC Definition The protobuf definition of GetOne is defined as such (for ExampleConfig):\nrpc GetOne (ExampleConfigRequest) returns (ExampleConfigResponse);Request Type The generated request for a model (ExampleConfig, here) looks like so:\nmessage ExampleConfigRequest { // Key uniquely identifies a ExampleConfig instance to retrieve.  // This value must be populated (non-null) and all fields set.  ExampleKey key = 1; // Time indicates the time for which you are interested in the data.  // If no time is given, the server will use the time at which it makes the request.  //  // This time is used as an upper-bound. The returned value may have been set at  // an earlier time, however, it was the value as of the supplied time.  google.protobuf.Timestamp time = 2;}Response Type The generated response for a model (ExampleConfig, here) looks like so:\nmessage ExampleConfigResponse { // Value is the value requested.  // This structure will be fully-populated as it exists in the datastore. If  // optional fields were not given at creation, these fields will be empty or  // set to default values.  ExampleConfig value = 1; // Time carries the (UTC) timestamp of the last-modification of the  // ExampleConfig instance in this response.  //  // As stated in the request above, this time will likely not match the request  // exactly. But it will be before-or-equal to the requested time.  google.protobuf.Timestamp time = 2;};"},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/getall/","title":"GetAll","tags":[],"description":"","content":"GetAll fetches (and optionally filters) all resource instances.\nFor the filtering options available, see the Filtering section. These filtering options are the same for Subscribe.\nThis RPC is effectively a full-table-scan so the time to complete depends on the amount of data the resource reflects. However, being a streaming API, this RPC will return the first message as soon as it is available without any buffering.\nRPC Definition The protobuf definition of GetAll is defined as such (for ExampleConfig):\nrpc GetAll (ExampleConfigStreamRequest) returns (stream ExampleConfigStreamResponse);Request Type The generated request for a model (ExampleConfig, here) looks like so:\nmessage ExampleConfigStreamRequest { // PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.  // This requires all provided fields to be equal to the response.  //  // While transparent to users, this field also allows services to optimize internal  // subscriptions if filter(s) are sufficiently specific.  repeated ExampleConfig partial_eq_filter = 1; //  // NOTE: Models are allowed to also contain a \u0026#34;implementation specific\u0026#34; filter  // which is more targetted, simple, or otherwise helpful.  // This filter type will be defined in the protobuf definition.  //  // TimeRange allows limiting response data to within a specified time window.  // If this field is populated, at least one of the two time fields are required.  //  // This field is not allowed in the Subscribe RPC.  arista.time.TimeBounds time = 3;};Time bounds GetAll allows retrieving the history of one or many instances of a resource. These options are passed through the TimeBounds message:\nmessage TimeBounds { google.protobuf.Timestamp start = 1; google.protobuf.Timestamp end = 2;}The fields start and end can be used in the following combinations:\n end: returns the state of resources at end.  responds with only fully-specified models   start: returns the state of resources at start and updates until now.  returns all fully-specified models as of the start time, and then all subsequent changes/partials/diffs   start and end: returns the state of resources at start as well as any changes until end.  same semantics as start alone, but only changes up to the end time    "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/subscribe/","title":"Subscribe","tags":[],"description":"","content":"Subscribe first returns the initial state (fully-specified messages) and then any received updates.\nThe first messages received are effectively the result of a GetAll). Once existing state has been sent to the client, any changes to resource entities are streamed back to the client. The update messages will represent what was updated and can either be a diff/partial or a fully-specified model.\nAny filters apply both to the initial state and updates.\n Clients can determine whether a given message is part of the initial GetAll or an update via the arista.subscriptions.Operation enum field on the StreamResponse type for the given resource. This enum can be found here.\nThe flow of messages follows these steps:\n N messages with arista.subscriptions.Operation::INITIAL One message with arista.subscriptions.Operation::INITIAL_SYNC_COMPLETE  this signifies the transition from initial data to udpates prevents the client from needing to hold the last operation to find transition point   N messages with either:  arista.subscriptions.Operation::UPDATED arista.subscriptions.Operation::DELETED these can happen in any order or frequency until the subscription/connection is closed    RPC Definition The protobuf definition of GetAll is defined as such (for ExampleConfig):\nrpc Subscribe (ExampleConfigStreamRequest) returns (stream ExampleConfigStreamResponse);"},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/set/","title":"Set","tags":[],"description":"","content":"Set updates a resource. Updates can be whole or partial (see: nullable fields) using only fields populated in the request.\nThe Key field is required to be fully-specified because Set needs to identify exactly-one resource to delete.\n The endpoint returns the time the Set becomes effective internally and the service\u0026rsquo;s known-state of the resource.\n A *SetResponse will contain an \u0026ldquo;echo\u0026rdquo; of the resource. This echo will be the original update-request at a minimum, and may include more data.This allows services to do fast, write-only, updates to internal storage. If the service needs to query existing state first then more data can be provided to the client. If you need a full model after a Set operation, you can issue a GetOne with the returned time.\nrpc Set (ExampleConfigSetRequest) returns (ExampleSetResponse);Request Type The generated request for a model (ExampleConfig, here) looks like so:\nmessage ExampleConfigSetRequest { // ExampleConfig carries the value to set into the datastore.  ExampleConfig value = 1;};Response Type The generated response for a model (ExampleConfig, here) looks like so:\nmessage ExampleConfigSetResponse { ExampleConfig value = 1; // Time indicates the (UTC) timestamp at which the system recognizes the  // creation. The only guarantees made about this timestamp are:  //  // - it is after the time the request was received  // - a time-ranged query with StartTime==CreatedAt will include this instance.  //  google.protobuf.Timestamp time = 2;};Updating maps Set maps are merged with the existing map.\nTo delete all of the values in a map, set the wrapper message of the map but leave the map itself empty.\nUpdating repeated fields Set repeated fields replace the existing array. For example:\nt0: existing state: ['a', 'b', 'c'] t1: existing state: ['a', 'b', 'c'] set request: ['a', 'q', 'z'] t2: existing state: ['a', 'q', 'z'] To delete all of the values in a repeated field, set the wrapper message of the repeated and leave the repeated empty.\nUpdating subresources Subresources are resources that are a child of another resource. A collection of subresources with compound keys is represented by a repeated field, though this collection should be treated as unordered and uses the same update semantics as maps (tuple keys are not allowed in protobuf maps). If multiple subresources with the same key are specified, the last one in the repeated ordering is assumed to be value.\nExample: Update Given an example proto:\nsyntax = \u0026#34;proto3\u0026#34;;import \u0026#34;google/protobuf/wrappers.proto\u0026#34;;message MapValue { google.protobuf.StringValue string_val = 1; google.protobuf.Int64Value int_val = 2;}message MapWrapper { map\u0026lt;string, MapValue\u0026gt; map = 1;}message RepeatedWrapper { repeated string repeated = 1;}message ExampleModel { google.protobuf.StringValue string_val = 1; google.protobuf.Int64Value int_val = 2; RepeatedWrapper repeated = 3; MapWrapper map = 4;}And a model:\nstring_val { value: \u0026#34;one\u0026#34; } int_val { value: 2 } repeated { repeated: \u0026#34;five\u0026#34; repeated: \u0026#34;six\u0026#34; } map { map { key: \u0026#34;four\u0026#34; value { string_val { value: \u0026#34;red\u0026#34; } int_val { value: 45 } } } map { key: \u0026#34;three\u0026#34; value { string_val { value: \u0026#34;blue\u0026#34; } int_val { value: 42 } } } map { key: \u0026#34;two\u0026#34; value { string_val { value: \u0026#34;purple\u0026#34; } int_val { value: 32 } } } } Applying the following update:\nstring_val { value: \u0026#34;two\u0026#34; } repeated { repeated: \u0026#34;eight\u0026#34; repeated: \u0026#34;nine\u0026#34; } map { map { key: \u0026#34;five\u0026#34; value { string_val { value: \u0026#34;orange\u0026#34; } int_val { value: 100 } } } map { key: \u0026#34;four\u0026#34; value { string_val { value: \u0026#34;green\u0026#34; } } } map { key: \u0026#34;three\u0026#34; value { string_val { value: \u0026#34;yellow\u0026#34; } int_val { value: 12 } } } } results in the updated model:\nstring_val { value: \u0026#34;two\u0026#34; } int_val { value: 2 } repeated { repeated: \u0026#34;eight\u0026#34; repeated: \u0026#34;nine\u0026#34; } map { map { key: \u0026#34;five\u0026#34; value { string_val { value: \u0026#34;orange\u0026#34; } int_val { value: 100 } } } map { key: \u0026#34;four\u0026#34; value { string_val { value: \u0026#34;green\u0026#34; } int_val { value: 45 } } } map { key: \u0026#34;three\u0026#34; value { string_val { value: \u0026#34;yellow\u0026#34; } int_val { value: 12 } } } map { key: \u0026#34;two\u0026#34; value { string_val { value: \u0026#34;purple\u0026#34; } int_val { value: 32 } } } } "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/rpcs/delete/","title":"Delete","tags":[],"description":"","content":"Delete deletes a resource and returns the time the delete became effective.\nThe Key field is required to be fully-specified because Delete needs to identify exactly-one resource to delete.\n RPC Definition The protobuf definition of GetOne is defined as such (for ExampleConfig):\nrpc Delete (ExampleConfigDeleteRequest) returns (ExampleConfigDeleteResponse);Request Type The generated request for a model (ExampleConfig, here) looks like so:\nmessage ExampleConfigDeleteRequest { // Key indicates which ExampleConfig instance to remove.  // This field must always be set.  ExampleKey key = 1;};Response Type The generated response for a model (ExampleConfig, here) looks like so:\nmessage ExampleConfigDeleteResponse { // Key echoes back the key of the deleted ExampleConfig instance.  ExampleKey key = 1; // Time indicates the (UTC) timestamp at which the system recognizes the  // deletion. The only guarantees made about this timestamp are:  //  // - it is after the time the request was received  // - a time-ranged query with StartTime==DeletedAt will not include this instance.  //  google.protobuf.Timestamp time = 2;};"},{"uri":"https://aristanetworks.github.io/cloudvision-apis/models/","title":"Models","tags":[],"description":"","content":"  event.v1   inventory.v1   tag.v1   "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/","title":"","tags":[],"description":"","content":"CloudVision APIs Cloudvision APIs are state based, resource-oriented APIs modeled in Protobuf and accessed over gRPC using a standardized set of RPC verbs.\nCloudVision is a powerful platform that processes and stores tremendous amounts of network data. It knows the topology of the network, device configuration, interface activity and other network events. These APIs allow access to fleet-wide data access and control, forming a management-plane with consistent usage.\nData Driven Functionality is defined in a data-oriented (rather than action-oriented) form. Designing the APIs to use state-synchronization confers some desirable traits:\nFor more information on modelling, see the Modeling page.\n Uniform APIs Adding a new API simply means creating a new model. Once a model is made, a set of consistent API verbs can then be generated for it. These verbs are named and behave the same across all models. For clients this makes it near trivial to adapt usage of one API to another.\nErgonomic Asynchronous APIs Synchronous APIs, while simple, have some classic problems. Take for example a DoReboot operation. This operation has numerous failure modes:\n Request Timeouts: perhaps the operation took longer than the client expected Network Interruption: similar to (1), but it\u0026rsquo;s entirely possible for a connection to break Device Bootlooping: perhaps rebooting is constantly failing. You must wait for a timeout to see that error. Service Interruption: perhaps the reboot service (or host machine) has unrelated issues during the request  In each of these cases, the client is now responsible of determining which failure mode occurred and how to proceed.\nIn a state-sharing paradigm a reboot request might be performed by setting a reboot request attribute to the current time. The service can return from this request almost immediately (only durably writing the request). Then the client can subscribe to a last-reboot attribute and knows the device has been rebooted successfully when that attribute’s timestamp exceeds that of the reboot request. State sharing allows the various components involved in an action not to need to care about each other; they just need to synchronize state when they come up, and then they’ll do the right thing.\nPortable By modelling in protobuf and exposing gRPC RPCs, this data and management is accessible from nearly any environment in nearly any language.\nFor Arista-supported clients, see the Existing Clients page. Alternatively, a basic guide on creating your own.\n In addition to pure-gRPC clients, HTTP REST mappings are easily generated through the great gRPC ecosystem. Thus, APIs can be utilized from nearly anywhere.\ngRPC Ecosystem Another benefit of using protobuf and gRPC is the vast ecosystem surrounding them. While portable client-generation is useful a well-supported ecosystem provides even more tooling.\nThis list is not extensive, nor an endorsement of any project. Many more tools can be found on the awesome-grpc page.\n  GUIs  BloomRPC Milkman   CLI Tools  GRPCurl evans   Talks and Tutorials  gRPC Overview: Talk at Slack by Varun Talwar gRPC: Google\u0026rsquo;s high-performance, open-source RPC framework by Sameer Ajmani gRPC: The Story of Microservices at Square \u0026hellip; and many more!    "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/categories/","title":"Categories","tags":[],"description":"","content":""},{"uri":"https://aristanetworks.github.io/cloudvision-apis/models/event.v1/","title":"event.v1","tags":[],"description":"","content":"  arista/event.v1/event.proto\n  Event\n  EventAck\n  EventAnnotationConfig\n  EventComponent\n  EventComponent.ComponentsEntry\n  EventComponents\n  EventData\n  EventData.DataEntry\n  EventKey\n  EventNote\n  EventNoteConfig\n  EventNotes\n  EventNotes.NotesEntry\n  EventNotesConfig\n  EventNotesConfig.NotesEntry\n  ComponentType\n  EventSeverity\n    arista/event.v1/services.gen.proto\n  EventAnnotationConfigDeleteRequest\n  EventAnnotationConfigDeleteResponse\n  EventAnnotationConfigRequest\n  EventAnnotationConfigResponse\n  EventAnnotationConfigSetRequest\n  EventAnnotationConfigSetResponse\n  EventAnnotationConfigStreamRequest\n  EventAnnotationConfigStreamResponse\n  EventRequest\n  EventResponse\n  EventStreamRequest\n  EventStreamResponse\n  EventAnnotationConfigService\n  EventService\n    \nTop\narista/event.v1/event.proto \nEvent Event is a telemetry event\n   Field Name Type Description     key EventKey key is the event instance identifier\n   severity EventSeverity severity is the severity of the event\n   title google.protobuf.StringValue title is the title of the event\n   description google.protobuf.StringValue description is the description of the event\n   event_type google.protobuf.StringValue event_type is the type of the event\n   data EventData data is the data of the event\n   components EventComponents components is the components on which the event occurred\n   ack EventAck ack is the acknowledgement status of the event\n   notes EventNotes notes is the notes of the event\n   last_updated_time google.protobuf.Timestamp last_updated_time is the time of the most recent update to the event\n    \nEventAck EventAck contains acknowledgement information of an event\n   Field Name Type Description     ack google.protobuf.BoolValue ack is the acknowledgement state of an event\n   acker google.protobuf.StringValue acker is the user that acknowledged the event\n   ack_time google.protobuf.Timestamp ack_time is the time of acknowledgement\n    \nEventAnnotationConfig EventAnnotationConfig configures an event annotation\n   Field Name Type Description     key EventKey key is the event instance identifier\n   ack google.protobuf.BoolValue ack is the acknowledgement state of an event\n   notes EventNotesConfig notes is the notes on an event\n    \nEventComponent EventComponent describes an entity on which the event occured\n   Field Name Type Description     type ComponentType type is the type of component\n   components EventComponent.ComponentsEntry[\u0026hellip;] components identifies the entity on which the event occured\n    \nEventComponent.ComponentsEntry    Field Name Type Description     key string \n   value string \n    \nEventComponents EventComponents contains entities on which an event occured\n   Field Name Type Description     components EventComponent[\u0026hellip;] components describes the components on which an event occured\n    \nEventData EventData is additional event data\n   Field Name Type Description     data EventData.DataEntry[\u0026hellip;] data is event data specific to the type of this event\n    \nEventData.DataEntry    Field Name Type Description     key string \n   value string \n    \nEventKey EventKey uniquely identifies an event\n   Field Name Type Description     key google.protobuf.StringValue key is the event data identifier\n   timestamp google.protobuf.Timestamp timestamp is the time the event occured\n    \nEventNote Eventnote is the state of a note\n   Field Name Type Description     note google.protobuf.StringValue note is the text of the note\n   note_creator google.protobuf.StringValue note_creator is the creator of the note\n    \nEventNoteConfig EventNoteConfig configures a note\n   Field Name Type Description     note google.protobuf.StringValue note is the text of the note\n    \nEventNotes EventNotes is the notes of an event state\n   Field Name Type Description     notes EventNotes.NotesEntry[\u0026hellip;] notes is keyed by the time desired\n    \nEventNotes.NotesEntry    Field Name Type Description     key int64 \n   value EventNote \n    \nEventNotesConfig EventNotesConfig configures the notes of an event\n   Field Name Type Description     notes EventNotesConfig.NotesEntry[\u0026hellip;] notes is keyed by desired note time in Unix time, in milliseconds\n    \nEventNotesConfig.NotesEntry    Field Name Type Description     key int64 \n   value EventNoteConfig \n    \nComponentType ComponentType describes the type of entity on which the event occured\n   Name Number Description     COMPONENT_TYPE_UNSPECIFIED 0 \n   COMPONENT_TYPE_DEVICE 1 \n   COMPONENT_TYPE_INTERFACE 2 \n   COMPONENT_TYPE_TURBINE 3 \n    \nEventSeverity EventSeverity is the severity level of the event\n   Name Number Description     EVENT_SEVERITY_UNSPECIFIED 0 \n   EVENT_SEVERITY_INFO 1 \n   EVENT_SEVERITY_WARNING 2 \n   EVENT_SEVERITY_ERROR 3 \n   EVENT_SEVERITY_CRITICAL 4 \n    \nTop\narista/event.v1/services.gen.proto \nEventAnnotationConfigDeleteRequest    Field Name Type Description     key EventKey Key indicates which EventAnnotationConfig instance to remove.\nThis field (and all keys, unless otherwise specified) must always be set.\n    \nEventAnnotationConfigDeleteResponse    Field Name Type Description     key EventKey Key echoes back the key of the deleted EventAnnotationConfig instance.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ndeletion. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==DeletedAt will not include this instance.\n    \nEventAnnotationConfigRequest    Field Name Type Description     key EventKey Key uniquely identifies a EventAnnotationConfig instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nEventAnnotationConfigResponse    Field Name Type Description     value EventAnnotationConfig Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nEventAnnotationConfig instance in this response.\n    \nEventAnnotationConfigSetRequest    Field Name Type Description     value EventAnnotationConfig EventAnnotationConfig carries the value to set into the datastore.\nSee the documentation on the EventAnnotationConfig struct for which fields are required.\n    \nEventAnnotationConfigSetResponse    Field Name Type Description     value EventAnnotationConfig Value carries all the values given in the EventAnnotationConfigSetRequest as well\nas any server-generated values.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ncreation. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==CreatedAt will include this instance.\n    \nEventAnnotationConfigStreamRequest    Field Name Type Description     partial_eq_filter EventAnnotationConfig[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nEventAnnotationConfigStreamResponse    Field Name Type Description     value EventAnnotationConfig Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this EventAnnotationConfig\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the EventAnnotationConfig value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nEventRequest    Field Name Type Description     key EventKey Key uniquely identifies a Event instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nEventResponse    Field Name Type Description     value Event Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nEvent instance in this response.\n    \nEventStreamRequest    Field Name Type Description     partial_eq_filter Event[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nEventStreamResponse    Field Name Type Description     value Event Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this Event\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the Event value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nEventAnnotationConfigService    Method Name Request Type Response Type Description     GetOne EventAnnotationConfigRequest EventAnnotationConfigResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll EventAnnotationConfigStreamRequest EventAnnotationConfigStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe EventAnnotationConfigStreamRequest EventAnnotationConfigStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n   Set EventAnnotationConfigSetRequest EventAnnotationConfigSetResponse Set allows setting values for the entity specified by the key in the request.\nThe key must be provided and all fields set (unless otherwise specified).\n   Delete EventAnnotationConfigDeleteRequest EventAnnotationConfigDeleteResponse Delete will remove the entity specified by the key within the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n    \nEventService    Method Name Request Type Response Type Description     GetOne EventRequest EventResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll EventStreamRequest EventStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe EventStreamRequest EventStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n    "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/models/inventory.v1/","title":"inventory.v1","tags":[],"description":"","content":"  arista/inventory.v1/inventory.proto\n  Device\n  DeviceKey\n  ExtendedAttributes\n  ExtendedAttributes.FeatureEnabledEntry\n  StreamingStatus\n    arista/inventory.v1/services.gen.proto\n  DeviceRequest\n  DeviceResponse\n  DeviceStreamRequest\n  DeviceStreamResponse\n  DeviceService\n    \nTop\narista/inventory.v1/inventory.proto \nDevice Device is the primary model for this service.\n   Field Name Type Description     key DeviceKey The key that uniquely identifies this device.\n   software_version google.protobuf.StringValue SoftwareVersion gives the currently running device software version.\n   model_name google.protobuf.StringValue ModelName describes the hardware model of this device.\n   hardware_revision google.protobuf.StringValue HardwareREvision describes any revisional data to the model name.\n   fqdn google.protobuf.StringValue FQDN gives the fully qualified hostname to reach the device.\n   hostname google.protobuf.StringValue Hostname is the hostname as reported on the device.\n   domain_name google.protobuf.StringValue DomainName provides the domain name the device is registered on.\n   system_mac_address google.protobuf.StringValue SystemMacAddress provides the MAC address of the management port.\n   boot_time google.protobuf.Timestamp BootTime indicates when the device was last booted.\n   streaming_status StreamingStatus StreamingStatus the status of streaming telemetry for this device.\n   extended_attributes ExtendedAttributes ExtendedAttributes wraps any additional, potentially non-standard, features\nor attributes the device reports.\n    \nDeviceKey DeviceKey uniquely identifies a single device.\n   Field Name Type Description     device_id google.protobuf.StringValue \n    \nExtendedAttributes ExtendedAttributes wraps any additional, potentially non-standard, features or attributes the device reports.\n   Field Name Type Description     feature_enabled ExtendedAttributes.FeatureEnabledEntry[\u0026hellip;] FeatureEnabled is a map of feature name to enabled status.\nIf a feature is missing from this map it can be assumed off.\n    \nExtendedAttributes.FeatureEnabledEntry    Field Name Type Description     key string \n   value bool \n    \nStreamingStatus StreamingStatus the status of streaming telemetry for this device.\n   Name Number Description     STREAMING_STATUS_UNSPECIFIED 0 Unspecified is the uninitialized state of this enum.\n   STREAMING_STATUS_INACTIVE 1 Inactive indicates the device is not streaming telemetry.\n   STREAMING_STATUS_ACTIVE 2 Active indicates the device is streaming telemetry.\n    \nTop\narista/inventory.v1/services.gen.proto \nDeviceRequest    Field Name Type Description     key DeviceKey Key uniquely identifies a Device instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nDeviceResponse    Field Name Type Description     value Device Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nDevice instance in this response.\n    \nDeviceStreamRequest    Field Name Type Description     partial_eq_filter Device[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nDeviceStreamResponse    Field Name Type Description     value Device Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this Device\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the Device value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nDeviceService    Method Name Request Type Response Type Description     GetOne DeviceRequest DeviceResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll DeviceStreamRequest DeviceStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe DeviceStreamRequest DeviceStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n    "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/models/tag.v1/","title":"tag.v1","tags":[],"description":"","content":"  arista/tag.v1/tag.proto\n  DeviceTag\n  DeviceTagAssignmentConfig\n  DeviceTagAssignmentKey\n  DeviceTagConfig\n  InterfaceTag\n  InterfaceTagAssignmentConfig\n  InterfaceTagAssignmentKey\n  InterfaceTagConfig\n  TagKey\n  CreatorType\n    arista/tag.v1/services.gen.proto\n  DeviceTagAssignmentConfigDeleteRequest\n  DeviceTagAssignmentConfigDeleteResponse\n  DeviceTagAssignmentConfigRequest\n  DeviceTagAssignmentConfigResponse\n  DeviceTagAssignmentConfigSetRequest\n  DeviceTagAssignmentConfigSetResponse\n  DeviceTagAssignmentConfigStreamRequest\n  DeviceTagAssignmentConfigStreamResponse\n  DeviceTagConfigDeleteRequest\n  DeviceTagConfigDeleteResponse\n  DeviceTagConfigRequest\n  DeviceTagConfigResponse\n  DeviceTagConfigSetRequest\n  DeviceTagConfigSetResponse\n  DeviceTagConfigStreamRequest\n  DeviceTagConfigStreamResponse\n  DeviceTagRequest\n  DeviceTagResponse\n  DeviceTagStreamRequest\n  DeviceTagStreamResponse\n  InterfaceTagAssignmentConfigDeleteRequest\n  InterfaceTagAssignmentConfigDeleteResponse\n  InterfaceTagAssignmentConfigRequest\n  InterfaceTagAssignmentConfigResponse\n  InterfaceTagAssignmentConfigSetRequest\n  InterfaceTagAssignmentConfigSetResponse\n  InterfaceTagAssignmentConfigStreamRequest\n  InterfaceTagAssignmentConfigStreamResponse\n  InterfaceTagConfigDeleteRequest\n  InterfaceTagConfigDeleteResponse\n  InterfaceTagConfigRequest\n  InterfaceTagConfigResponse\n  InterfaceTagConfigSetRequest\n  InterfaceTagConfigSetResponse\n  InterfaceTagConfigStreamRequest\n  InterfaceTagConfigStreamResponse\n  InterfaceTagRequest\n  InterfaceTagResponse\n  InterfaceTagStreamRequest\n  InterfaceTagStreamResponse\n  DeviceTagAssignmentConfigService\n  DeviceTagConfigService\n  DeviceTagService\n  InterfaceTagAssignmentConfigService\n  InterfaceTagConfigService\n  InterfaceTagService\n    \nTop\narista/tag.v1/tag.proto \nDeviceTag DeviceTag is a label-value pair that may or may not be assigned to a device.\n   Field Name Type Description     key TagKey Key uniquely identifies the device tag.\n   creator_type CreatorType CreatorType is the creator type of the tag.\n    \nDeviceTagAssignmentConfig DeviceTagAssignmentConfig is the assignment of a device tag to a specific device.\n   Field Name Type Description     key DeviceTagAssignmentKey Key uniquely identifies the device tag assignment.\n    \nDeviceTagAssignmentKey DeviceTagAssignmentKey uniquely identifies a device tag assignment.\n   Field Name Type Description     label google.protobuf.StringValue Label is the label of the tag.\n   value google.protobuf.StringValue Value is the value of the tag.\n   device_id google.protobuf.StringValue DeviceId is the ID of the device.\n    \nDeviceTagConfig DeviceTagConfig is a label-value pair that may or may not be assigned to a device.\n   Field Name Type Description     key TagKey Key uniquely identifies the device tag.\n    \nInterfaceTag InterfaceTag is a label-value pair that may or may not be assigned to an interface.\n   Field Name Type Description     key TagKey Key uniquely identifies the interface tag.\n   creator_type CreatorType CreatorType is the creator type of the tag.\n    \nInterfaceTagAssignmentConfig InterfaceTagAssignmentConfig is the assignment of an interface tag to a specific interface.\n   Field Name Type Description     key InterfaceTagAssignmentKey Key uniquely identifies the interface tag assignment.\n    \nInterfaceTagAssignmentKey InterfaceTagAssignmentKey uniquely identifies an interface tag assignment.\n   Field Name Type Description     label google.protobuf.StringValue Label is the label of the tag.\n   value google.protobuf.StringValue Value is the value of the tag.\n   device_id google.protobuf.StringValue DeviceId is the ID of the interface\u0026rsquo;s device.\n   interface_id google.protobuf.StringValue InterfaceId is the ID of the interface.\n    \nInterfaceTagConfig InterfaceTagConfig is a label-value pair that may or may not be assigned to an interface.\n   Field Name Type Description     key TagKey Key uniquely identifies the interface tag.\n    \nTagKey TagKey uniquely identifies a tag for a network element.\n   Field Name Type Description     label google.protobuf.StringValue Label is the label of the tag.\n   value google.protobuf.StringValue Value is the value of the tag.\n    \nCreatorType CreatorType specifies an entity that creates something.\n   Name Number Description     CREATOR_TYPE_UNSPECIFIED 0 \n   CREATOR_TYPE_SYSTEM 1 CREATOR_TYPE_SYSTEM is the type for something created by the system.\n   CREATOR_TYPE_USER 2 CREATOR_TYPE_USER is the type for something created by a user.\n    \nTop\narista/tag.v1/services.gen.proto \nDeviceTagAssignmentConfigDeleteRequest    Field Name Type Description     key DeviceTagAssignmentKey Key indicates which DeviceTagAssignmentConfig instance to remove.\nThis field (and all keys, unless otherwise specified) must always be set.\n    \nDeviceTagAssignmentConfigDeleteResponse    Field Name Type Description     key DeviceTagAssignmentKey Key echoes back the key of the deleted DeviceTagAssignmentConfig instance.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ndeletion. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==DeletedAt will not include this instance.\n    \nDeviceTagAssignmentConfigRequest    Field Name Type Description     key DeviceTagAssignmentKey Key uniquely identifies a DeviceTagAssignmentConfig instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nDeviceTagAssignmentConfigResponse    Field Name Type Description     value DeviceTagAssignmentConfig Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nDeviceTagAssignmentConfig instance in this response.\n    \nDeviceTagAssignmentConfigSetRequest    Field Name Type Description     value DeviceTagAssignmentConfig DeviceTagAssignmentConfig carries the value to set into the datastore.\nSee the documentation on the DeviceTagAssignmentConfig struct for which fields are required.\n    \nDeviceTagAssignmentConfigSetResponse    Field Name Type Description     value DeviceTagAssignmentConfig Value carries all the values given in the DeviceTagAssignmentConfigSetRequest as well\nas any server-generated values.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ncreation. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==CreatedAt will include this instance.\n    \nDeviceTagAssignmentConfigStreamRequest    Field Name Type Description     partial_eq_filter DeviceTagAssignmentConfig[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nDeviceTagAssignmentConfigStreamResponse    Field Name Type Description     value DeviceTagAssignmentConfig Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this DeviceTagAssignmentConfig\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the DeviceTagAssignmentConfig value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nDeviceTagConfigDeleteRequest    Field Name Type Description     key TagKey Key indicates which DeviceTagConfig instance to remove.\nThis field (and all keys, unless otherwise specified) must always be set.\n    \nDeviceTagConfigDeleteResponse    Field Name Type Description     key TagKey Key echoes back the key of the deleted DeviceTagConfig instance.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ndeletion. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==DeletedAt will not include this instance.\n    \nDeviceTagConfigRequest    Field Name Type Description     key TagKey Key uniquely identifies a DeviceTagConfig instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nDeviceTagConfigResponse    Field Name Type Description     value DeviceTagConfig Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nDeviceTagConfig instance in this response.\n    \nDeviceTagConfigSetRequest    Field Name Type Description     value DeviceTagConfig DeviceTagConfig carries the value to set into the datastore.\nSee the documentation on the DeviceTagConfig struct for which fields are required.\n    \nDeviceTagConfigSetResponse    Field Name Type Description     value DeviceTagConfig Value carries all the values given in the DeviceTagConfigSetRequest as well\nas any server-generated values.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ncreation. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==CreatedAt will include this instance.\n    \nDeviceTagConfigStreamRequest    Field Name Type Description     partial_eq_filter DeviceTagConfig[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nDeviceTagConfigStreamResponse    Field Name Type Description     value DeviceTagConfig Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this DeviceTagConfig\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the DeviceTagConfig value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nDeviceTagRequest    Field Name Type Description     key TagKey Key uniquely identifies a DeviceTag instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nDeviceTagResponse    Field Name Type Description     value DeviceTag Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nDeviceTag instance in this response.\n    \nDeviceTagStreamRequest    Field Name Type Description     partial_eq_filter DeviceTag[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nDeviceTagStreamResponse    Field Name Type Description     value DeviceTag Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this DeviceTag\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the DeviceTag value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nInterfaceTagAssignmentConfigDeleteRequest    Field Name Type Description     key InterfaceTagAssignmentKey Key indicates which InterfaceTagAssignmentConfig instance to remove.\nThis field (and all keys, unless otherwise specified) must always be set.\n    \nInterfaceTagAssignmentConfigDeleteResponse    Field Name Type Description     key InterfaceTagAssignmentKey Key echoes back the key of the deleted InterfaceTagAssignmentConfig instance.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ndeletion. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==DeletedAt will not include this instance.\n    \nInterfaceTagAssignmentConfigRequest    Field Name Type Description     key InterfaceTagAssignmentKey Key uniquely identifies a InterfaceTagAssignmentConfig instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nInterfaceTagAssignmentConfigResponse    Field Name Type Description     value InterfaceTagAssignmentConfig Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nInterfaceTagAssignmentConfig instance in this response.\n    \nInterfaceTagAssignmentConfigSetRequest    Field Name Type Description     value InterfaceTagAssignmentConfig InterfaceTagAssignmentConfig carries the value to set into the datastore.\nSee the documentation on the InterfaceTagAssignmentConfig struct for which fields are required.\n    \nInterfaceTagAssignmentConfigSetResponse    Field Name Type Description     value InterfaceTagAssignmentConfig Value carries all the values given in the InterfaceTagAssignmentConfigSetRequest as well\nas any server-generated values.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ncreation. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==CreatedAt will include this instance.\n    \nInterfaceTagAssignmentConfigStreamRequest    Field Name Type Description     partial_eq_filter InterfaceTagAssignmentConfig[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nInterfaceTagAssignmentConfigStreamResponse    Field Name Type Description     value InterfaceTagAssignmentConfig Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this InterfaceTagAssignmentConfig\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the InterfaceTagAssignmentConfig value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nInterfaceTagConfigDeleteRequest    Field Name Type Description     key TagKey Key indicates which InterfaceTagConfig instance to remove.\nThis field (and all keys, unless otherwise specified) must always be set.\n    \nInterfaceTagConfigDeleteResponse    Field Name Type Description     key TagKey Key echoes back the key of the deleted InterfaceTagConfig instance.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ndeletion. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==DeletedAt will not include this instance.\n    \nInterfaceTagConfigRequest    Field Name Type Description     key TagKey Key uniquely identifies a InterfaceTagConfig instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nInterfaceTagConfigResponse    Field Name Type Description     value InterfaceTagConfig Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nInterfaceTagConfig instance in this response.\n    \nInterfaceTagConfigSetRequest    Field Name Type Description     value InterfaceTagConfig InterfaceTagConfig carries the value to set into the datastore.\nSee the documentation on the InterfaceTagConfig struct for which fields are required.\n    \nInterfaceTagConfigSetResponse    Field Name Type Description     value InterfaceTagConfig Value carries all the values given in the InterfaceTagConfigSetRequest as well\nas any server-generated values.\n   time google.protobuf.Timestamp Time indicates the (UTC) timestamp at which the system recognizes the\ncreation. The only guarantees made about this timestamp are:\n- it is after the time the request was received\n- a time-ranged query with StartTime==CreatedAt will include this instance.\n    \nInterfaceTagConfigStreamRequest    Field Name Type Description     partial_eq_filter InterfaceTagConfig[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nInterfaceTagConfigStreamResponse    Field Name Type Description     value InterfaceTagConfig Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this InterfaceTagConfig\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the InterfaceTagConfig value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nInterfaceTagRequest    Field Name Type Description     key TagKey Key uniquely identifies a InterfaceTag instance to retrieve.\nThis value (and all fields, unless otherwise specified) must be populated.\n   time google.protobuf.Timestamp Time indicates the time for which you are interested in the data.\nIf no time is given, the server will use the time at twhich it makes the request.\n    \nInterfaceTagResponse    Field Name Type Description     value InterfaceTag Value is the value requested.\nThis structure will be fully-populated as it exists in the datastore. If\noptional fields were not given at creation, these fields will be empty or\nset to default values.\n   time google.protobuf.Timestamp Time carries the (UTC) timestamp of the last-modification of the\nInterfaceTag instance in this response.\n    \nInterfaceTagStreamRequest    Field Name Type Description     partial_eq_filter InterfaceTag[\u0026hellip;] PartialEqFilter provides a way to server-side filter a GetAll/Subscribe.\nThis requires all provided fields to be equal to the response.\nWhile transparent to users, this field also allows services to optimize internal\nsubscriptions if filter(s) are sufficiently specific.\n   time arista.time.TimeBounds TimeRange allows limiting response data to within a specified time window.\nIf this field is populated, at least one of the two time fields are required.\nThis field is not allowed in the Subscribe RPC.\n    \nInterfaceTagStreamResponse    Field Name Type Description     value InterfaceTag Value is a value deemed relevant to the initiating request.\nThis structure will always have its key-field populated. Which other fields are\npopulated, and why, depends on the value of Operation and what triggered this notification.\n   time google.protobuf.Timestamp Time holds the timestamp of this InterfaceTag\u0026rsquo;s last modification.\n   type arista.subscriptions.Operation Operation indicates how the InterfaceTag value in this response should be considered.\nUnder non-subscribe requests, this value should always be INITIAL. In a subscription,\nonce all initial data is streamed and the client begins to receive modification updates,\nyou should not see INITIAL again.\n    \nDeviceTagAssignmentConfigService    Method Name Request Type Response Type Description     GetOne DeviceTagAssignmentConfigRequest DeviceTagAssignmentConfigResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll DeviceTagAssignmentConfigStreamRequest DeviceTagAssignmentConfigStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe DeviceTagAssignmentConfigStreamRequest DeviceTagAssignmentConfigStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n   Set DeviceTagAssignmentConfigSetRequest DeviceTagAssignmentConfigSetResponse Set allows setting values for the entity specified by the key in the request.\nThe key must be provided and all fields set (unless otherwise specified).\n   Delete DeviceTagAssignmentConfigDeleteRequest DeviceTagAssignmentConfigDeleteResponse Delete will remove the entity specified by the key within the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n    \nDeviceTagConfigService    Method Name Request Type Response Type Description     GetOne DeviceTagConfigRequest DeviceTagConfigResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll DeviceTagConfigStreamRequest DeviceTagConfigStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe DeviceTagConfigStreamRequest DeviceTagConfigStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n   Set DeviceTagConfigSetRequest DeviceTagConfigSetResponse Set allows setting values for the entity specified by the key in the request.\nThe key must be provided and all fields set (unless otherwise specified).\n   Delete DeviceTagConfigDeleteRequest DeviceTagConfigDeleteResponse Delete will remove the entity specified by the key within the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n    \nDeviceTagService    Method Name Request Type Response Type Description     GetOne DeviceTagRequest DeviceTagResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll DeviceTagStreamRequest DeviceTagStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe DeviceTagStreamRequest DeviceTagStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n    \nInterfaceTagAssignmentConfigService    Method Name Request Type Response Type Description     GetOne InterfaceTagAssignmentConfigRequest InterfaceTagAssignmentConfigResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll InterfaceTagAssignmentConfigStreamRequest InterfaceTagAssignmentConfigStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe InterfaceTagAssignmentConfigStreamRequest InterfaceTagAssignmentConfigStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n   Set InterfaceTagAssignmentConfigSetRequest InterfaceTagAssignmentConfigSetResponse Set allows setting values for the entity specified by the key in the request.\nThe key must be provided and all fields set (unless otherwise specified).\n   Delete InterfaceTagAssignmentConfigDeleteRequest InterfaceTagAssignmentConfigDeleteResponse Delete will remove the entity specified by the key within the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n    \nInterfaceTagConfigService    Method Name Request Type Response Type Description     GetOne InterfaceTagConfigRequest InterfaceTagConfigResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll InterfaceTagConfigStreamRequest InterfaceTagConfigStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe InterfaceTagConfigStreamRequest InterfaceTagConfigStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n   Set InterfaceTagConfigSetRequest InterfaceTagConfigSetResponse Set allows setting values for the entity specified by the key in the request.\nThe key must be provided and all fields set (unless otherwise specified).\n   Delete InterfaceTagConfigDeleteRequest InterfaceTagConfigDeleteResponse Delete will remove the entity specified by the key within the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n    \nInterfaceTagService    Method Name Request Type Response Type Description     GetOne InterfaceTagRequest InterfaceTagResponse GetOne returns a unary model as specified by the key in the request.\nThe key must be provided and all fields populated (unless otherwise specified).\n   GetAll InterfaceTagStreamRequest InterfaceTagStreamResponse stream GetAll returns all entities for this model, with optional filtering.\n   Subscribe InterfaceTagStreamRequest InterfaceTagStreamResponse stream Subscribe first returns all initial state known to the system,\nthen will send deltas as entities are changed.\n    "},{"uri":"https://aristanetworks.github.io/cloudvision-apis/tags/","title":"Tags","tags":[],"description":"","content":""}]